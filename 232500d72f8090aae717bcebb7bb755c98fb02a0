Maintenant que notre test passe, il faut passer à l'étape 2 du walking skeletong : utiliser l'UI comme primary adapter.

Le problème que l'on a ici c'est que tout est déclaré directement dans le test. Il exite des dépendances implicites.

En effet, la classe `AdddBookUseCase` dépend directement de `bookRepository` que l'on déclare dans le test.

Ca marche dans notre exemple, mais ça ne marchera plus dès que l'on voudra changer d'adapter : passer des tests à l'UI par exemple.

C'est ici que rentre en jeu la notion de "ports" dans l'architecture ports & adapters.

Le principe est très simple : l'application (ici composée d'un seul et unique use case : `AddBookUseCase`) doit définir les contrats qu'elle comprend en entrée, et avec lesquels elle peut communiquer en sortie.

Dans notre cas, il y a deux contrats :

- le contrat lié à l'actor primaire, qui va "driver" l'application. Ici il s'agit d'expliciter le fait qu'il existe un point d'entrée "AddBookuseCase" dans l'application. Dans le pattern de base, il faudrait ici créer une interface explicitement, qui serait implémentée par le use case. En pratique, on peut souvent s'en passer. Ce n'est donc pas tout à fait de l'architecture ports & adapters "by the books".
- le contrat lié à la communication avec le monde extérieur. Ici il s'agit de pouvoir sauvegarder un livre. L'application définit donc qu'elle est capable de communiquer avec n'importe qui qui implementerait le contrat `save(book: { title: string })`. Et comment on représente un contrat généralement ? Via une interface !

Pour instaurer la mise en place de ces contrats, et surtout du deuxième donc (puisque le premier peut être omis si on décide de s'éloigner de la vision "pure"), il faut que notre couche application, le use case AddBookUseCase déclare qu'il peut communiquer avec le contrat lié à la communication extérieure. Plutôt que de dépendre directement de l'implémentation concrète BookRepository, il dépend maintenant de l'interface BookRepository. L'implémentation concrète se voit injectée dans le constructeur. Ce faisant, AddBookUseCase déclare qu'il doit nécessairement pouvoir communiquer avec un objet qui respecte le contrat de l'interface BookRepository. Il s'en fiche de savoir l'implémentation concrète derrière.

+import { AddBookUseCase } from './add-book.usecase';
+import { StubBookRepository } from './stub.book-repository';
+
 describe('Feature: Adding a book', () => {
   test('Example: User can add a book', async () => {
-    class BookRepository {
-      lastSavedBook: { title: string } | undefined;
-    }
-
-    const bookRepository = new BookRepository();
-
-    class AddBookUseCase {
-      async execute(book: { title: string }) {
-        bookRepository.lastSavedBook = book;
-      }
-    }
+    const bookRepository = new StubBookRepository(); // ici on instantie notre stub de BookRepository

-    const addBook = new AddBookUseCase();
+    const addBook = new AddBookUseCase(bookRepository); // la dépendance est maintenant injectée.

     await addBook.execute({ title: 'Clean Code' });

Le use case est maintenant dans son propre fichier.

`add-book.usecase.ts`
```diff
 -0,0 +1,9 @@
+import { BookRepository } from './book-repository.port';
+
+export class AddBookUseCase {
+  constructor(private readonly bookRepository: BookRepository) {}
+
+  execute(book: { title: string }) {
+    return this.bookRepository.save(book);
+  }
+}
```

Un définit explicitement le contrat d'interface du port BookRepository :

`book-repository.port.ts`
```diff
+export interface BookRepository {
+  save(book: { title: string }): Promise<void>;
+}
```

Il suffit maintenant d'implémenter un `StubBookRepository` (qui est en fait ici plutôt un spy, dans le sens où sa seule fonctionnalité pour le moment est "d'espionner" le fait qu'on a voulu sauvegarder un livre) :

`stub.book-repository.ts`
```diff
 -0,0 +1,9 @@
+import { BookRepository } from './book-repository.port';
+
+export class StubBookRepository implements BookRepository {
+  lastSavedBook: { title: string } | undefined;
+
+  async save(book: { title: string }): Promise<void> {
+    this.lastSavedBook = book;
+  }
+}
```
