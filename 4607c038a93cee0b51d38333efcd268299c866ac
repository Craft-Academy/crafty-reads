Maintenant que storybook est configuré, commençons par le premier composant : le bouton.

`src/components/button.tsx`
```ts
import * as elements from 'typed-html';

export const Button = ({ name, type }: { name: string; type: string }) => {
  return (
    <button
      class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline"
      type={type}
    >
      {name}
    </button>
  );
};
```

Et la story qui va avec :

`src/stories/Button.stories.ts`
```ts
import type { StoryObj, Meta } from '@storybook/html';
import { Button } from '../components/button';

// More on how to set up stories at: https://storybook.js.org/docs/writing-stories#default-export
const meta = {
  title: 'Example/Button',
  tags: ['autodocs'],
  render: (args) => {
    // You can either use a function to create DOM elements or use a plain html string!
    // return `<div>${label}</div>`;
    return Button(args);
  },
  argTypes: {
    name: { control: 'color' },
    type: { control: 'text' },
  },
} satisfies Meta<{ name: string; type: string }>;

export default meta;
type Story = StoryObj<{ name: string; type: string }>;

// More on writing stories with args: https://storybook.js.org/docs/writing-stories/args
export const Primary: Story = {
  args: {
    name: 'Foo Bar',
    type: 'submit',
  },
};
```

Ne reste plus qu'à démarrer storybook :

`npm run storybook`

Et voici le résultat :

{% embed url="https://app.arcade.software/share/wC02h1eM5D63sTi1Ep8T" %}

Créons maintenant le layout de l'application :

`src/components/layout.tsx`
```ts
import * as elements from 'typed-html';

export const Layout = ({ children }: elements.Attributes) => {
  return (
    <html>
      <head>
        <title>Crafty Reads</title>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <script src="https://cdn.tailwindcss.com"></script>
        <script
          src="https://unpkg.com/htmx.org@2.0.1"
          integrity="sha384-QWGpdj554B4ETpJJC9z+ZHJcA/i59TyjxEPXiiUgN2WmTyV5OEZWCD6gQhgkdpB/"
          crossorigin="anonymous"
        ></script>
        <script src="//unpkg.com/alpinejs" defer=""></script>
      </head>
      <body>
        <main class="container mx-auto px-4 py-8">{children}</main>
        {/* Cette partie concerne la gestion des messages type toast. J'utilise des attributs Alpine.js pour gérer la transition et l'affichage du toast.
        On va voir ensuite comment gérer le toast dans notre code.
        */}
        <div
          aria-live="assertive"
          class="pointer-events-none fixed inset-0 flex items-end px-4 py-6 sm:items-start sm:p-6"
        >
          <div class="flex w-full flex-col items-center space-y-4 sm:items-end">
            <div
              id="toast-container"
              x-transition:enter="transform ease-out duration-300 transition"
              x-transition:enter-start="translate-y-2 opacity-0 sm:translate-y-0 sm:translate-x-2"
              x-transition:enter-end="translate-y-0 opacity-100 sm:translate-x-0"
              x-transition:leave="transition ease-in duration-100"
              x-transition:leave-start="opacity-100"
              x-transition:leave-end="opacity-0"
            ></div>
          </div>
        </div>
      </body>
    </html>
  );
};
```

Passons maintenant au composant du formulaire :

`src/components/add-book-form.tsx`
```ts
import * as elements from 'typed-html';
import { Button } from './button';
import { Toast } from './toast';

export const AddBookForm = ({
  inputPlaceholder,
  toast,
}: {
  inputPlaceholder: string;
  toast?: {
    type: 'error' | 'success';
    title: string;
    message: string;
  };
}) => {
  return (
    <div id="add-book-form">
      <form
        action="/"
        class="bg-white shadow-md rounded px-8 pt-6 pb-8 mb-4"
        method="post"
        hx-boost="true"
        hx-target="#add-book-form"
        hx-swap="outerHTML"
      >
        <div class="mb-4">
          <label class="block text-gray-700 text-sm font-bold mb-2" for="title">
            Title
          </label>
          <input
            class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline"
            id="title"
            type="text"
            name="title"
            placeholder={inputPlaceholder}
            required="required"
          />
        </div>
        <Button name="Add Book" type="submit" />
      </form>
      {toast && (
        <Toast title={toast.title} message={toast.message} type={toast.type} />
      )}
    </div>
  );
};
```

Rien que de très classique ici, on a un formulaire qui envoie une requête à l'API et qui affiche un toast en fonction du résultat, le tout en utilisant htmx pour éviter de recharger la page grâce à l'attribut hx-boost.

Voici comment est géré le toast :

`src/components/toast.tsx`
```ts
import * as elements from 'typed-html';

export const Toast = ({
  title,
  message,
  type,
}: {
  title: string;
  message: string;
  type: 'error' | 'success';
}) => {
  return (
    <div
      id="toast-container"
      hx-swap-oob="true"
      x-data="{ open: true }"
      x-init="setTimeout(() => open = false, 1500)"
      class="pointer-events-auto w-full max-w-sm overflow-hidden rounded-lg bg-white shadow-lg ring-1 ring-black ring-opacity-5"
      x-show="open"
    >
      <div class="p-4">
        <div class="flex items-start">
          <div class="flex-shrink-0">
            {`<svg
              class="h-6 w-6 text-${type === 'success' ? 'green' : 'red'}-400"
              fill="none"
              viewBox="0 0 24 24"
              stroke-width="1.5"
              stroke="currentColor"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>`}
          </div>
          <div class="ml-3 w-0 flex-1 pt-0.5">
            <p class="text-sm font-medium text-gray-900">{title}</p>
            <p class="mt-1 text-sm text-gray-500">{message}</p>
          </div>
          <div class="ml-4 flex flex-shrink-0">
            <button
              type="button"
              x-on:click="open = false"
              class="inline-flex rounded-md bg-white text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
            >
              <span class="sr-only">Close</span>
              {`<svg
                class="h-5 w-5"
                viewBox="0 0 20 20"
                fill="currentColor"
                aria-hidden="true"
              >
                <path d="M6.28 5.22a.75.75 0 00-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 101.06 1.06L10 11.06l3.72 3.72a.75.75 0 101.06-1.06L11.06 10l3.72-3.72a.75.75 0 00-1.06-1.06L10 8.94 6.28 5.22z" />
              </svg>`}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};
```

Plusieurs choses à noter :

- On utilise x-data="{ open: true }" pour gérer l'ouverture et la fermeture du toast.
- On utilise x-init="setTimeout(() => open = false, 1500)" pour fermer le toast après 1.5s.
- On utilise hx-swap-oob="true" qui permet d'injecter le toast en dehors du formulaire, dans le container définit par le même `id` dans le body.
- typed-html ne gère pas les svg natif, on doit donc utiliser une string pour les insérer.

Ne reste plus qu'à modifier le controller pour utiliser ces composants :

`src/app.controller.tsx`
```ts
import * as elements from 'typed-html';
import { Body, Controller, Get, Post } from '@nestjs/common';
import { AddBookUseCase } from './add-book.usecase';
import { Layout } from './components/layout';
import { AddBookForm } from './components/add-book-form';

@Controller()
export class AppController {
  constructor(private readonly addBookUseCase: AddBookUseCase) {}

  @Get()
  index(): string {
    return (
      <Layout>
        <AddBookForm inputPlaceholder="Enter book title" />
      </Layout>
    );
  }

  @Post()
  async addBook(@Body() body: { title: string }) {
    try {
      await this.addBookUseCase.execute({ title: body.title });
      return (
        <AddBookForm
          inputPlaceholder="Enter book title"
          toast={{
            type: 'success',
            title: 'Book added',
            message: 'The book has been added to the list',
          }}
        />
      );
    } catch (error) {
      return (
        <AddBookForm
          inputPlaceholder="Enter book title"
          toast={{
            type: 'error',
            title: 'Book not added',
            message: (error as any).message,
          }}
        />
      );
    }
  }
}
```

Attention ici j'ai renommé le controller en .tsx car on utilise du jsx à travers les composants. On verra plus tard s'il est souhaitable de faire autrement ;)

Et voici le résultat :

{% embed url="https://app.arcade.software/share/AdrW62uQqkmSYYfBzPC3" %}
